# JavaSE基础知识：面向对象、基本语法、异常处理

本文全面介绍了JavaSE基础知识，涵盖了面向对象编程的核心概念（如继承、封装、多态和抽象），详解了Java中的访问权限修饰符、对象克隆、静态和实例变量的区别，以及抽象类和接口的不同之处。文章还讨论了Java中的异常处理机制，包括Error与Exception类的区别、编译时和运行时异常的处理方式，最后介绍了I/O流、字节流与字符流的转换、序列化机制等内容，是Java面试准备的实用参考。





## 1 面向对象

### 1.1 面向对象的特性

* **继承**：从已有类得到继承信息创建新类的过程。提供继承信息的类称为**父类**（超类、基类）；得到继承信息的类称为**子类**（派生类）。继承让变化中的软件系统有了一定的延续性，同时也是封装程序中可变因素的重要手段。
* **封装**：把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。在类中编写的方法就是对实现细节的一种封装，即编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的**编程接口**。
* **多态**：允许不同子类型的对象对同一消息作出不同的响应，即用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为**编译时的多态性**和**运行时的多态性**。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式， 但一切对A系统来说都是透明的。方法**重载**（Overload）实现的是编译时的多态性（也称为**前绑定**），而方法**重写** （Override）实现的是运行时的多态性（也称为**后绑定**）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：① 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；② 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。

默认情况下面向对象有3大特性——封装、继承、多态，有时也称抽象为第4大特性：

* **抽象**：将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对 象有哪些属性和行为，并不关注这些行为的细节是什么。

>* 注意String类是final类，不可被继承。
>* Java 中实现多态的机制是什么？
>【答】靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变 量的类型中定义的方法。

### 1.2 访问权限修饰符

不同的权限修饰符的区别见下表（不写表示默认default）：

|修饰符|当前类|同包|子类|其他包|
|--|--|--|--|--|
|**public**|✓|✓|✓|✓|
|**protected**|✓|✓|✓|×|
|**default**|✓|✓|×|×|
|**private**|✓|×|×|×|


### 1.3 对象克隆

在实际编程过程中，常会遇到这种情况：有一个对象A，在某一时刻A中已经包含了一些有效值，此时可能会需要一个和A完全相同新对象B，并且此后对B任何改动都不会影响到A中的值，也就是说，A与B是两个独立的对象，但B的初始值是由A对象确定的。在Java语言中，用简单的赋值语句是不能满足这种需求的。要满足这种需求虽然有很多途径，但实现`clone()`方法是其中最简单，也是最高效的手段。

#### 1.3.1 new和clone()的过程

* **new**操作符的本意是分配内存。程序执行到new操作符时，首先去看new操作符后的类型（因为只有知道类型后， 才能知道要分配多大的内存空间）。分配完内存后，再调用构造函数，填充对象的各个域，这一步叫做**对象的初始化**。构造方法返回后，一个对象创建完毕，可以将其引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。
* `clone()`方法在第一步与new相似，都是分配内存，但调用方法时，分配的内存和原对象（即调用方法的对象）相同。然后再使用原对象中对应的各个域，填充新对象的域，填充完成之后方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。


#### 1.3.2 复制引用和复制对象

以下代码执行后打印的地址值是相同的，说明`p`和`p1`只是引用而已，他们都指向了一个相同的对象。这种现象称为**复制引用**。

```java
Person p = new Person(23, "zhang");
Person p1 = p;
System.out.println(p);
System.out.println(p1);
```

![复制引用](https://www.hyperplasma.top/wp-content/uploads/2024/08/e3be39bc2d6742f98a3a75b174d078ff.png)

以下代码才是真正的**克隆对象**，所打印的两个对象的地址是不同的，也就是说创建了新的对象， 而不是把原对象的地址赋给了一个 新的引用变量。

```java
Person p = new Person(23, "zhang");
Person p1 = (Person) p.clone();
System.out.println(p);
System.out.println(p1);
```

![克隆对象](https://www.hyperplasma.top/wp-content/uploads/2024/08/76dddcb849674486942d7ca80d4c9ab2.png)



#### 1.3.3 深拷贝和浅拷贝

以下示例代码的Person类中有两个成员变量，分别是age和result，age是int型，result是Result类。要想使用clone，需实现**Cloneable**接口并实现`clone()`方法。如下所示：

```java
public class Person implements Clonable {
	private int age;
	private Result result;
	
	public Person() {}

	public Person(int age, Result result) {
		this.age = age;
		this.result = result;
	}

	public int getAge() {
		return this.age;
	}

	public Result getResult() {
		return this.result;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return (Person) super.clone();
	}
}
```
由于age是基本数据类型，那么对它的拷贝为直接将一个4字节的整数值拷贝就行。
但result是引用类型， 则对它的拷贝有两种方式：直接将原对象中引用型成员的引用值拷贝给新对象对应的字段——**浅拷贝**；或根据原对象中的引用型成员指向的对象创建一个新的相同的对象，将其引用赋给新对象对应的字段——**深拷贝**。

`clone()`方法**默认执行浅拷贝**。要想实现深拷贝，需在`clone()`方法内部，**把该对象的其他引用对象也要clone一份**，这就要求**这个被引用的对象必须也要实现 Cloneable接口**并实现`clone()`方法。如下例所示：

```java
@Override
protected Object clone() throws CloneNotSupportedException {
	Person newPerson = (Person) super.clone();
	newPerson.result = (Result) this.result.clone();
	return newPerson;
}
```

### 1.4 静态变量和实例变量

* **静态变量**：被static修饰符修饰的变量，也称为类变量。它属于类，不属于类的任何一个对象。一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝。
* **实例变量**：必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。

静态变量可以实现让多个对象共享内存。


### 1.5 抽象类和接口

* 不同点
	* **抽象类**（Abstract Class）
		1. 如果一个类中有**抽象方法**，那么这个类一定是抽象类；但抽象类可以没有抽象方法
		2. 可以存在构造方法
		3. 可以存在普通属性、方法、静态属性和静态方法
		4. 抽象类中的抽象方法需要有子类实现，如果子类不实现，则子类也需要定义为抽象的
	* **接口**（Interface）
		1. 接口中的方法永远都被public来修饰
		2. 没有构造方法，也不能实例化接口对象
		3. 只有方法的声明，没有方法体
		4. 只能定义常量，如果定义变量，在编译的时候都会默认加上“public static final”
		5. 接口中定义的方法都需要实现类来实现，如果实现类不能实现接口中的所有方法，则实现类需要定义为抽象类
		6. 静态方法不能被子类重写（覆盖），因此接口中不定声明静态方法
		7. 使用接口可以实现多继承
* 相同点
	1. 不能实例化
	2. 可以将抽象类和接口类型作为引用类型
	3. 一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍需要被声明为抽象类

>* 抽象方法是否可同时是静态的 (static), 是否可同时是本地方法 (native)，是否可同时被synchronized
>【答】都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由 本地代码（如 C 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关， 抽象方法不涉及实现细节，因此也是相互矛盾的。




### 1.6 静态嵌套类和内部类

 * **静态嵌套类**（Static Nested Class）：被声明为静态（static）的内部类，可以不依赖于外部类实例被实例化。
* **内部类**（Inner Class）：需要在外部类实例化后才能实例化。

Java中非静态内部类对象的创建要依赖其外部类对象

【例】以下代码中的`foo()`和`main()`均为静态方法，没有`this`，即没有所谓的外部类对象，因此无法直接创建内部类对象。只能通过实例化外部类后再实例化内部类。

```java
class Outer {
	class Inner {}
	
	public static void foo() {
		// new Inner(); 无法实例化内部类
		new Outer().new Inner();
	}

	public void bar() {
		new Inner();
	}

	public static void main(String[] args) {
		// new Inner(); 无法实例化内部类
		new Outer().new Inner();
	}
}
```



---


## 2 JavaSE语法

### 2.1 基本数据类型

Java 的基本数据类型所占字节数如下表所示

|数据类型|字节数|数据表示范围|
|--|--|--|
|**byte**|1|-128 ~ 127|
|**short**|2|-32768 ~ 32767|
|**int**|4|-2147483648 ~ 2147483647|
|**long**|8|-2^63^ ~ 2^63^-1|
|**float**|4|-3.403E38 ~ 3.403E38|
|**double**|8|-1.798E308 ~ 1.798E308|
|**char**|2|表示一个字符，如`'a'`、`'A'`、`0`、`'龍'`|
|**boolean**|1|`true` or `false`


>* String是引用类型，底层用char数组实现。详见：[字符串类](https://akira.blog.csdn.net/article/details/138909181)
>* Java5以前，`switch(expr)`中，expr只能是 byte、short、char、int。
>从Java 5开始，引入了枚举类型， expr也可以是enum类型。 
>从Java 7开始，expr还可以是字符串（String），但长整型（long）在目前所有的版本中都是不可以的。




### 2.2 Java中的goto语句

**goto**是Java中的保留字，在目前版本的Java中没有使用。根据James Gosling（Java 之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个关键字目前无法使用，因此有些地方称之为保留字（其实保留字这个词应有更广泛的意义，因为熟悉C语言的都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）。

>* 在Java中，如何跳出当前的多重嵌套循环
>【答】在最外层循环前加一个标记如`A`，用 `break A;`可以跳出多重循环。（Java 中支持带标签的break和continue语句，作用类似C和C++中的goto语句，但是就像要避免使用goto一样，应避免使用带标签的 break 和 continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用）。


### 2.3 &和&&

* `&`运算符有两种用法：(1)按位与；(2)逻辑与。
* `&&`运算符的作用是**短路**与运算，若左边的表达式的值为false，右边的表达式会直接不进行运算。

一般情况下都使用`&&`而非`&`，例如在验证用户登录时判定用户名非null且非空字符串，应写为`username != null && !username.equals("")`，二者的顺序不能交换，更不能用`&`运算符，因为第一个条件若不成立，根本不能进行字符串的`equals()`比较，否则会产生NullPointerException空指针异常。

逻辑或运算符`|`和短路或运算符`||`同理。

### 2.4 值传递和引用传递

Java语言的方法调用只支持参数的**值传递**。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++和C##中可通过传引用或传输出参数来改变传入的参数的值。

>* 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?
>【答】是值传递。Java 语言的方法调用只支持参数的值传递。



### 2.5 重载和重写

方法的**重载**（Overload）和**重写**（Override）都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重写时要给方法追加`@Override`注解。

重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。

* 方法重载的规则：
	1. 方法名一致，参数列表中参数的顺序、类型、个数不同。 
	2. 重载与方法的返回值无关，存在于父类和子类之间、同类中。
	3. 可以抛出不同的异常，可以有不同修饰符。
* 方法重写的规则：
	1. 参数列表必须完全与被重写方法的一致，返回类型必须完全与被重写方法的返回类型一致。
	2. 构造方法不能被重写，声明为final的方法不能被重写。声明为static的方法不能被重写，但能够被再次声明。
	3. 访问权限不能比父类中被重写的方法的访问权限更低。
	4. 重写的方法能够抛出任何**非强制异常**（UncheckedException，非运行时异常），无论被重写的方法是否抛出异常。但重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常。

>* 为什么函数不能根据返回类型来区分重载？
>【答】因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。

### 2.6 equals()和hashCode()

Java对于`equals()`和`hashCode()`方法的规定如下：
1. 如果两个对象相同（即`equals()`返回 true），那么它们的`hashCode()`值一定相同。
2. 如果两个对象的 `hashCode()`相同，它们并不一定相同。

>实际可以违背上述规定，但此时就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素 的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。

在Joshua Bloch的《Effective Java》中这样介绍`equals()`方法：首先须满足以下原则——

1. **自反性**：`x.equals(x)`必须返回true
2. **对称性**：`x.equals(y)`返回true时，`y.equals(x)`也必须返回true
3. **传递性**：`x.equals(y)`和`y.equals(z)`都返回 true时，`x.equals(z)`也必须返回true
4. **一致性**：当`x`和`y`引用的对象信息没有被修改时，多次调用`x.equals(y)`应该得到同样的返回值
5. 对于任何非null值的引用`x`，`x.equals(null)`必须返回false

实现高质量的 equals 方法的诀窍包括：
1. 使用`==`操作符检查“参数是否为这个对象的引用”
2. 使用`instanceof`操作符检查“参数是否为正确的类型”
3. 对于类中的关键属性，检查参数传入对象 的属性是否与之相匹配
4. 编写完后，检查是否满足对称性、传递性、一致性
5. 重写时总是同时重写`hashCode()`
6. 不要将参数中的Object对象替换为其他的类型

>* `==`和`equals()`的区别
>【答】一个是方法，一个是运算符——
>	* `==`：如果比较的对象是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是对象的地址值是否相等。 
>	* `equals()`：用来比较方法两个对象的内容是否相等。不能用于基本数据类型变量，如果没有对`equals()`方法进行重写，则比较的是引用类型的变量所指向的对象的地址。

### 2.7 字符编码方式

Java中使用的编码是**Unicode**（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char 类型占**2个字节**（16 比特），因此可以存储一个中文汉字。

使用Unicode意味着字符在JVM内部和外部有不同的表现形式：在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务。






---

## 3 异常处理


### 3.1 异常处理机制

Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable， Throwable下面又派生了Error和Exception两个子类。


#### 3.1.1 Error类和Exception类

* **Error类**：一般指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等。对于这类 错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。
* **Exception类**：表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。按照异常需要处理的时机，又分为分为**编译时异常**和**运行时异常** 。

#### 3.1.2 编译时异常和运行时异常

只有java语言提供了**编译时异常**（**CheckedException**，强制性异常），Java认为编译时异常都是可以被处理的异常，所以Java程序必须显式处理编译时异常。如果程序没有处理编译时异常，该程序在编译时就会发生错误无法编译。这体现了Java的设计哲学：没有完善错误处理的代码根本没有机会被执行。
对编译时异常处理方法有两种：
1. 当前方法知道如何处理该异常，则用`try...catch`块来处理该异常。注意异常机制有这么一个原则：如果在catch中遇到return或异常等使得该函数终止，那么若有finally就必须**先执行finally代码块**里面的代码然后再返回值。
2. 当前方法不知道如何处理，则在定义该方法时用`throws`字句声明抛出该异常。

**运行时异常**（**RuntimeException**、非强制性异常）只有当代码在运行时才发行的异常（如除数为0、数组下标越界等），编译时不需要`try...catch`。Runtime异常产生频繁，处理麻烦，若显式声明或捕获将会对程序的可读性和运行效率影响很大。所以由系统自动检测并将它们交给缺省的异常处理程序。当然如果有处理要求也可以显式捕获它们。


#### 3.1.3 常见的RuntimeException

* **java.lang.NullPointerException**：空指针异常。出现原因：调用了未经初始化的对象或者是不存在的对象。 
* **java.lang.ClassNotFoundException**：指定的类找不到。出现原因：类的名称和路径加载错误；通常都是程序 试图通过字符串来加载某个类时可能引发异常。 
* **java.lang.NumberFormatException**：字符串转换为数字异常。出现原因：字符型数据中包含非数字型字符。
* **java.lang.IndexOutOfBoundsException**：数组角标越界异常，常见于操作数组对象时发生。
* **java.lang.IllegalArgumentException**：方法传递参数错误。
* **java.lang.ClassCastException**：数据类型转换异常。


### 3.2 throw和throws的区别

* `throw`
	1. throw语句用在方法体内，表示抛出异常，由方法体内的语句处理。
	2. 是具体向外抛出异常的动作，所以它抛出的是一个异常实例，执行throw语句一定是抛出了某种异常。 
* `throws`
	1. throws语句用在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理。
	2. throws声明这个方法会抛出某种类型的异常，让它的使用者知道需要捕获的异常的类型。
	3. throws表示出现异常的一种可能性，并不一定会发生这种异常。


### 3.3 final、finally、finalize()的区别

* **final**：用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，被其修饰的类不可继承。
* **finally**：异常处理语句结构的一部分，表示总是执行。
* `finalize()`：Object类的一个方法，在垃圾回收器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。该方法更像是对象生命周期的临终方法，当该方法被系统调用则代表该对象即将“死亡”。注：主动调用该方法并不会导致该对象“死亡”，因为这是一个被动的方法（实为回调方法），不需要我们调用。

---

## 4 IO流

### 4.1 流的类型

* 按照流的方向分类
	* **输入流**（**InputStream**）
	* **输出流**（**OutputStream**）
* 按照实现功能分类
	* **节点流**：可以从或向一个特定的地方（节点）读写数据。如FileReader。
	* **处理流**：对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。
* 按照处理数据的单位分类
	* **字节流**（继承于InputStream和OutputStream）
	* **字符流**（继承于InputStreamReader和OutputStreamWriter）



### 4.2 字节流和字符流

![字符流](https://www.hyperplasma.top/wp-content/uploads/2024/08/c2ccd445a35341dbbfbe54ddcd732c19.jpeg)

![字节流](https://www.hyperplasma.top/wp-content/uploads/2024/08/7f68557db6a4477db0cb643cddda0b4d.jpeg)


* 字节流读取时，读到一个字节就返回一个字节； 字符流使用了字节流读到一个或多个字节时，根据指定的编码表，将对应的字符返回（中文对应的字节数是两个，在 UTF-8 码表中是 3 个字节）。 
* 字节流可以处理所有类型数据（主要为byte型数据），如图片、MP3、AVI视频文件；字符流只能处理字符数据。因此只要是处理纯文本数据，就优先考虑使用字符流，除此之外都用字节流。
* 字节流转字符流：
字节输入流转字符输入流通过**InputStreamReader**实现，该类的构造函数可以传入**InputStream**对象。
字节输出流转字符输出流通过**OutputStreamWriter**实现，该类的构造函数可以传入**OutputStream**对象。

### 4.3 序列化

**序列化**是一种处理对象流的机制，用于解决在对对象流进行读写操作时所引发的问题。**对象流**为将对象的内容进行流化，可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。

实现：将需要被序列化的类实现**Serializable**接口， 该接口没有需要实现的方法，只是为了标注该对象是可被序列化的。使用一个输出流（如FileOutputStream）构造一个**ObjectOutputStream**对象流对象（抛出IOException），再使用该对象的`writeObject(obj)`方法将对象obj写出（即保存其状态）。输入流的实现同理。

【例】将java对象序列化到文件里

```java
// 对象输入流
ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(new File("test_obj")));
objectOutputStream.writeObject(new User("akira", 37));
objectOutputStream.close();

// 对象输入流
ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(new File("text_obj")));
User user = (User) objectInputStream.readObject();
System.out.println(user);
objectInputStream.close();
```








