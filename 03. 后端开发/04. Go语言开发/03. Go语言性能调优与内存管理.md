# Go语言性能调优与内存管理

Go后端进阶教程——性能调优与内存管理

## 1 性能调优

### 1.1 提高性能的细节

#### 1.1.1 slice、map预分配内存

尽可能在使用`make()`初始化切片时提供容量信息

```go
func PreAlloc(size int) {
	data := make([]int, 0, size)	// 设置第3个参数size
	for k := 0; k < size; k++ {
		data = append(data, k)
	}
}
```

map同slice

```go
func PreAlloc(size int) {
	data := make(map[int]int, size)	// 传入第2个参数size
	for i := 0; i < size; i++ {
		data[i] = 1
	}
}
```

#### 1.1.2 copy代替re-slice

如下所示，推荐使用`copy()`函数而非直接返回重切片

```go
func GetLastBySlice(origin []int) []int {
	return origin[len(origin)-2:]
}

func GetLastByCopy(origin []int) []int {
	result := make([]int, 2)
	copy(result, origin[len(origin)-2:])	// 使用copy硬拷贝切片
	return result
}
```

#### 1.1.3 使用string.builder

拼接字符串时，使用`+`拼接性能最差，strings.Builder、bytes.Buffer相近，strings.Buffer更快。

分析：

* 字符串在Go语言中是不可变类型，占用内存大小是固定的
* 使用`+`每次都会重新分配内存
* strings.Builder、bytes.Buffer底层都是`[]byte`数组
* Go语言有特殊的内存扩容策略，不需要每次拼接重新分配内存

内部原理：

* bytes.Buffer转化为字符串时重新申请了一块空间

```go
// To build strings more effictently, see the strings.Butlder type.
func (b *Buffer) String() string {
	if b == nil {
		// Special case, useful in debugging.
		return "<nil>"
	}
	return string(b.buf[b.off:])
}
```

* strings.Builder直接将底层的`[]byte`转换成了字符串类型返回

```go
// String returns the accumulated string.
func (b *Builder) String() string {
	return *(*string)(unsafe.Pointer(&b.buf))
}
```


#### 1.1.4 使用`map`+空结构体

空结构体`struct{}`实例不占据任何的内存空间，可作为各种场景下的占位符使用。

优点如下：

* 节省资源
* 空结构体本身具备很强的语义，即这里不需要任何值，仅作为占位符

```go
func BoolMap(n int) {
	m := make(map[int]bool)
	for i := 0; i < n; i++ {
		m[i] = false;
	}
}

func EmptyStructMap(n int) {
	m := make(map[int]struct{})		// 使用空结构体
	for i := 0; i < n; i++ {
		m[i] = struct{}{}	// 初始化为空结构体实例
	}
}
```

#### 1.1.5 使用atomic包

* 锁的实现是通过操作系统来实现，属于系统调用；atomic操作是通过硬件实现，效率比锁高
* sync.Mutex应用来保护一段逻辑，不仅仅用于保护一个变量
* 对于非数值操作，可以使用atomic.Value，能承载一个`interface{}`，

### 1.2 性能分析工具pprof

性能调优原则：

* 要依靠数据不是猜测
* 要定位最大瓶颈而不是细枝末节
* 不要过度优化
* 不要过早优化

### 1.3 企业性能调优

* 业务服务优化
* 基础库优化
* Go语言优化


---

## 2 内存管理


### 2.1 垃圾回收基础知识

动态内存：程序在运行时根据需求动态分配的内存（参考C的`malloc()`）

自动内存管理（垃圾回收，GC）：由程序语言的运行时系统管理动态内存（参考Java的GC）

* 避免手动内存管理，专注于实现业务逻辑
* 保证内存使用的正确性和安全性：double-free problem，use-after-free problem

三个任务：

* 为新对象分配空间
* 找到存活对象
* 回收死亡对象的内存空间

Mutator：业务线程，分配新对象，修改对象指向关系

Collector：GC线程，找到存活对象，回收死亡对象的内存空间

* Serial GC：只有一个collector
* Parallel GC：支持多个collectors同时回收的GC算法
* Concurrent GC：mutator(s) 和 collector(s) 可以同时执行


#### 2.1.1 对象回收策略

对象被回收的条件：指针指向关系不可达的对象

流程：

1. 标记根对象：静态变量、全局变量、常量、线程栈等
2. 标记可达对象
	* 求指针指向关系的传递闭包：从根对象出发，找到所有可达对象
3. 清理所有不可达对象。存在以下3种策略：
	* Copying GC：将存活对象复制到另外的内存空间 （）
	* Mark-sweep GC：将死亡对象的内存标己为“可分配”；使用free list管理空闲内存
	* Mark-compact GC：移动并整理存活对象；原地整理对象

#### 2.1.2 分代GC

分代假说（Generational Hypothesis）：most objects die young

Intuition：很多对象在分配出来后很快就不再使用了

> 参考JVM的GC

每个对象都有年龄（经历过GC的次数），不同年龄的对象处于heap的不同区域

目的：针对年轻和老年的对象，制定不同的GC策略，降低整体内存管理的开销

* 年轻代 （Young Generation）
	* 常规的对象分配
	* 由于存活对象很少，可以采用copying collection
	* GC吞吐率很高

* 老年代（Old Generation）
	* 对象趋向于一直活着，反复复制开销较大
	* 可以采用mark-sweep collection

#### 2.1.3 引用计数

每个对象都有一个与之关联的引用数目

对象存活的条件：当且仅当引用数大于0

优点：

* 内存管理的操作被平摊到程序执行过程中
* 内存管理不需要了解runtime的实现细节（C++智能指针）

缺点：
* 维护引用计数的开销较大：通过**原子操作**保证对引用计数操作的**原子性**和**可见性**
* 无法回收环形数据结构——weak reference
* 内存开销：每个对象都引入的额外内存空间存储引用数目
* 回收内存时依然可能引发暂停

### 2.2 Go内存管理与优化

#### 2.2.1 Go内存分配——分块

Go有特殊的分块策略：

使用`mmap()`申请大块内存：

* `mmap()`是一个系统调用，用于在用户空间与内核空间之间映射文件或设备到内存。可以使用`mmap()`来申请一大块内存，例如4MB。
* 这种方法的好处是可以避免频繁的系统调用，因为之后的内存分配可以从这块大内存中进行，而不是每次都向操作系统请求小块内存。

内存划分为大块（mspan）：

* 将申请到的内存划分为较大的块，称为**mspan**，例如每块8KB。
* 这种划分使得内存管理更加高效，因为可以更好地控制内存的使用和分配。

进一步划分为小块：
* 每个mspan可以进一步划分为更小的块，用于实际的对象分配。这些小块的大小可以根据预期的对象大小进行调整。
* 这种策略可以减少内存碎片，提高内存利用率。

分配方式：
1. **noscan mspan**：
	* 这种类型的mspan用于分配不包含指针的对象。由于这些对象不持有任何引用，垃圾收集器（GC）在运行时不需要扫描这些对象的内存。
	* 这意味着分配和释放这些对象时，GC的负担会减轻，从而提高性能。
2. **scan mspan**：
	* 这种类型的mspan用于分配包含指针的对象。GC需要扫描这些对象，以确定它们所引用的其他对象是否仍然存活。
	* 由于需要扫描，GC的实现必须相对复杂，以确保内存的有效管理。

对象分配策略：

* 在实际进行对象分配时，系统会根据对象的大小选择最合适的块（无论是来自noscan mspan还是scan mspan）。
* 这样的策略使得内存管理更加灵活，同时也能够有效地应对不同类型对象的内存需求。

通过这种方式，内存的分配和管理可以变得更加高效和优化，尤其是在需要频繁分配和释放对象的情况下。

#### 2.2.2 Go内存分配——缓存

**TCMalloc**是Google开发的一种高效的内存分配器，专为多线程环境优化。其核心思想是通过**线程缓存**（Thread Caching）来减少锁竞争，提高内存分配的速度。

每个线程的缓存（mcache）：

* 每个线程（通常标记为`p`）都有一个自己的**mcache**，用于快速分配对象。这个设计减少了多线程环境中对全局锁的需求，从而提高了性能。
* mcache是一个缓存结构，专门用于存储为特定线程分配的对象，以便快速重复使用。

mcache管理mspan：

* mcache管理一组mspan，每个mspan是一个较大的内存块，进一步划分为小块以供对象分配。
* 当线程需要分配对象时，首先检查自己的mcache。如果mcache中有可用的对象，则直接从中分配，避免了更复杂的全局分配过程。

向mcentral申请mspan：

* 当mcache中的mspan所有对象都被分配完毕，线程会向**mcentral**申请新的mspan。
* mcentral是一个全局的内存管理器，负责管理多个线程的mcache。

mspan的缓存机制：

* 如果一个mspan中的所有对象都被分配并使用完毕，TCMalloc不会立即释放这块内存并归还给操作系统。
* 相反，这个mspan会被缓存到mcentral中，以便将来可能的再次分配。这种设计可以减少频繁的内存申请和释放操作，从而提高性能。
* 由此mcentral可以快速响应不同线程的内存需求，而无需每次都请求操作系统分配新的内存。


通过上述机制，TCMalloc在多线程环境中实现了高效的内存管理。每个线程的mcache提供了快速的对象分配，减少了锁竞争；而mcentral则通过缓存机制优化了内存的使用，确保了系统的高效性和响应性。这种设计理念使得TCMalloc特别适合在需要高性能内存分配的应用场景中使用。

#### 2.2.3 Balanced GC

使用pprof可发现，Go中小对象的分配极多。

对象本质与小对象分配：

* 在Go中，内存管理的一个挑战是处理多个小对象的分配。传统的分配方式可能会导致频繁的内存申请和释放，从而引起内存碎片和延迟释放。
* **GAB**（Garbage Allocated Blocks）是一种对象分配策略，旨在将多个小对象的分配合并为一次的对象分配，以提高效率。
	* 用于noscan类型的小对象分配（< 128 B）
	* 使用三个指针维护GAB：`base`、`end`、`top`
	* Bump pointer（指针碰撞）风格对象分配——无须和其他分配请求互斥；分配动作简单高效

内存延迟释放的问题：

* GAB的对象分配方式可能导致内存被延迟释放。即使某些对象不再被使用，它们仍可能占用内存，直到垃圾收集器运行并释放它们。
* 这种延迟释放可能会导致内存的使用效率降低，尤其是在创建和销毁大量小对象时。

解决方案——移动存活的对象：

* 为了优化内存管理，Balanced GCGAB提出了一种机制：当GAB的总大小超过某个设定的阈值时，系统会对存活的对象进行移动。即将GAB中仍然存活的对象复制到一个新的、分配的GAB中。
* 这意味着：
	* 只保留那些仍然需要的对象，释放掉不再需要的对象的内存。
	* 原先的GAB被标记为可释放的，从而避免内存泄漏。

使用复制垃圾收集（copying GC） 算法：
* Balanced GCGAB的本质在于使用copying GC来管理小对象，通过复制存活对象到新的内存空间，从而实现内存的回收和整理。
* 这种算法的优势在于：
	* 能够有效地整理内存，减少碎片，提高内存的使用效率。
	* 通过移动存活对象，能够快速释放不再使用的内存，减少延迟释放的情况。

---

## 3 编译器与静态分析

### 3.1 编译器简介

编译器分为前端和后端，此处重点优化的是后端，数据流和控制流的分析是优化的基础

### 3.2 静态分析

静态分析：不执行程序代码，推导程序的行为，分析程序的性质。

控制流（Control Flow）：程序执行的流程

数据流（Data Flow）：数据在控制流上的传递

通过分析控制流和数据流，我们可以知道更多关于程序的性质（properties）。根据这些性质优化代码：

* 过程内分析 （Intra-procedural analysis）：仅在过程内部进行分析
* 过程间分析 （Inter-procedural analysis）：考虑过程调用时参数传递和返回值的数据流和控制流

>为什么过程间分析是个问题？
> * 需要通过数据流分析得知`i`的具体类型，才能知道`i.foo()`调用的是哪个`foo()`
> * 根据`i`的具体类型，产生**新的控制流**，`i.foo()`，分析继续
> * 过程间分析需要**同时**分析控制流和数据流——**联合求解**，比较复杂

### 3.3 Go编译器优化

为何要编译器优化：

* 用户无感知，重新编译即可获得性能收益
* 通用性优化

现状：

* 采用的优化少
* 编译时间较短，没有进行较复杂的代码分析和优化

编译优化的思路：

* 场景：面向后端长期执行任务
* Tradeoff： 用编译时间换取更高效的机器码

### 3.4 Beast mode

#### 3.4.1 函数内联

**内联**（Inlining）：将被调用函数的函数体（callee）的副本替换到调用位置（caller）上，同时重写代码以反映参数的绑定

优点：

* 消除函数调用开销，例如传递参数、保存寄存器等
* 将过程间分析转化为过程内分析，帮助其他优化，例如逃逸分析

缺点：

* 函数体变大，instruction cache（icache）不友好
* 编译生成的Go镜像变大

> 函数内联在大多数情况下是正向优化

内联策略：调用和被调函数的规模；……

#### 3.4.2 逃逸分析

**逃逸分析**（Escape Analysis）：分析代码中指针的动态作用域，即指针在何处可以被访问

大致思路：

1. 从对象分配处出发，沿着控制流，观察对象的数据流
2. 若发现指针`p`在当前作用域`S`——
	- 作为参数传递给其他函数
	- 传递给全局变量
	- 传递给其他的goroutine
	- 传递给已逃逸的指针指向的对象
3. 满足上述任意一条则指针`p`指向的对象逃逸出`S`，反之则没有逃逸出`S`

> Beast mode的函数内联**拓展了函数边界**，更多对象**不逃逸**

优化：未逃逸的对象可以在**栈上分配**，好处如下
* 对象在栈上分配和回收很快：移动sp（Stack Pointer）即可完成内存的分配和回收
* 減少在heap上的分配，降低GC负担

#### 3.4.3 死代码消除

死代码消除（Dead Code Elimination）：移除不再使用的代码，减少不必要的代码路径，从而减小可执行文件的大小和提高执行效率。

#### 3.4.4 循环优化

对循环进行优化，例如循环展开、移动不变代码等，以减少循环体内的重复计算。










